73ba7407bcd3f4ab4bfdc6faae18c6d5
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('../config/supabase');
jest.mock('../services/empire/EmpireResolutionService');
jest.mock('../middleware/auth');
jest.mock('../services/bases/StatsService');
jest.mock('../services/bases/CapacityService');
const supertest_1 = __importDefault(require("supertest"));
const express_1 = __importDefault(require("express"));
const bases_1 = __importDefault(require("../routes/game/bases"));
const auth_1 = require("../middleware/auth");
const supabase_1 = require("../config/supabase");
const response_formats_1 = require("../constants/response-formats");
// Mock dependencies
const database_fields_1 = require("../../../constants/database-fields");
const mockSupabase = supabase_1.supabase;
const mockEmpireResolutionService = EmpireResolutionService;
const mockAuthenticate = auth_1.authenticate;
// Test app setup
const app = (0, express_1.default)();
app.use(express_1.default.json());
app.use('/bases', bases_1.default);
// Mock user for authentication
const mockUser = {
    _id: 'user123',
    id: 'user123',
    username: 'testuser'
};
const mockEmpire = {
    id: 'empire123',
    name: 'Test Empire',
    territories: ['A00:00:01:01', 'A00:00:01:02']
};
describe('Bases Routes - Territory Migration (FR-16, FR-17, FR-18)', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        // Mock authentication middleware
        mockAuthenticate.mockImplementation((req, res, next) => {
            req.user = mockUser;
            next();
        });
        // Mock empire resolution
        mockEmpireResolutionService.resolveEmpireByUserObject.mockResolvedValue(mockEmpire);
    });
    describe('GET /bases - Territory Listing (migrated from v1)', () => {
        it('should return territories list from colonies table (FR-16)', async () => {
            // Mock colonies data (preferred source)
            const mockColonies = [
                { location_coord: 'A00:00:01:01', name: 'Alpha Base' },
                { location_coord: 'A00:00:01:02', name: 'Beta Outpost' }
            ];
            const mockQuery = {
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({ data: mockColonies, error: null })
            };
            mockSupabase.from.mockReturnValue(mockQuery);
            const response = await (0, supertest_1.default)(app)
                .get('/bases')
                .expect(response_formats_1.HTTP_STATUS.OK);
            expect(response.body).toEqual({
                success: true,
                data: {
                    territories: [
                        { coord: 'A00:00:01:01', name: 'Alpha Base' },
                        { coord: 'A00:00:01:02', name: 'Beta Outpost' }
                    ]
                }
            });
            expect(mockQuery.eq).toHaveBeenCalledWith(database_fields_1.DB_FIELDS.BUILDINGS.EMPIRE_ID, 'empire123');
        });
        it('should fallback to empires.territories when no colonies exist (FR-18)', async () => {
            // Mock empty colonies, fallback to empire territories
            const mockEmptyColonies = { data: [], error: null };
            const mockEmpireData = { data: { territories: ['A00:00:01:01', 'A00:00:01:02'] }, error: null };
            const mockLocations = { data: [{ coord: 'A00:00:01:01' }, { coord: 'A00:00:01:02' }], error: null };
            const mockColoniesQuery = {
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue(mockEmptyColonies)
            };
            const mockEmpireQuery = {
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                maybeSingle: jest.fn().mockResolvedValue(mockEmpireData)
            };
            const mockLocationQuery = {
                select: jest.fn().mockReturnThis(),
                in: jest.fn().mockResolvedValue(mockLocations)
            };
            mockSupabase.from
                .mockReturnValueOnce(mockColoniesQuery) // colonies query
                .mockReturnValueOnce(mockEmpireQuery) // empires query  
                .mockReturnValueOnce(mockLocationQuery); // locations query
            const response = await (0, supertest_1.default)(app)
                .get('/bases')
                .expect(response_formats_1.HTTP_STATUS.OK);
            expect(response.body).toEqual({
                success: true,
                data: {
                    territories: [
                        { coord: 'A00:00:01:01' },
                        { coord: 'A00:00:01:02' }
                    ]
                }
            });
        });
        it('should return empty array when no territories exist', async () => {
            const mockEmptyColonies = { data: [], error: null };
            const mockEmptyEmpire = { data: { territories: [] }, error: null };
            const mockColoniesQuery = {
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue(mockEmptyColonies)
            };
            const mockEmpireQuery = {
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                maybeSingle: jest.fn().mockResolvedValue(mockEmptyEmpire)
            };
            mockSupabase.from
                .mockReturnValueOnce(mockColoniesQuery)
                .mockReturnValueOnce(mockEmpireQuery);
            const response = await (0, supertest_1.default)(app)
                .get('/bases')
                .expect(response_formats_1.HTTP_STATUS.OK);
            expect(response.body).toEqual({
                success: true,
                data: { territories: [] }
            });
        });
        it('should return 404 when empire not found (FR-15)', async () => {
            mockEmpireResolutionService.resolveEmpireByUserObject.mockResolvedValue(null);
            const response = await (0, supertest_1.default)(app)
                .get('/bases')
                .expect(response_formats_1.HTTP_STATUS.NOT_FOUND);
            expect(response.body).toEqual({
                success: false,
                error: response_formats_1.ERROR_MESSAGES.EMPIRE_NOT_FOUND
            });
        });
    });
    describe('GET /bases/:coord/stats - Base Statistics (migrated from v1)', () => {
        it('should return base statistics using StatsService (FR-16)', async () => {
            const mockStats = {
                area: 1000,
                energy: { production: response_formats_1.HTTP_STATUS.INTERNAL_SERVER_ERROR, consumption: response_formats_1.HTTP_STATUS.OK },
                population: { current: 1000, capacity: 2000 }
            };
            // Mock StatsService
            const mockStatsService = {
                getBaseStats: jest.fn().mockResolvedValue(mockStats)
            };
            // Mock dynamic import { HTTP_STATUS, ERROR_MESSAGES } from '../constants/response-formats';
            jest.doMock('../../../services/bases/StatsService', () => ({
                StatsService: mockStatsService
            }));
            const response = await (0, supertest_1.default)(app)
                .get('/bases/A00:00:01:01/stats')
                .expect(response_formats_1.HTTP_STATUS.OK);
            expect(response.body).toEqual({
                success: true,
                data: { stats: mockStats }
            });
        });
        it('should return 400 when coordinate is missing (FR-15)', async () => {
            const response = await (0, supertest_1.default)(app)
                .get('/bases//stats')
                .expect(response_formats_1.HTTP_STATUS.BAD_REQUEST);
            expect(response.body).toEqual({
                success: false,
                error: response_formats_1.ERROR_MESSAGES.COORDINATE_PARAMETER_REQUIRED
            });
        });
        it('should return 404 when empire not found (FR-15)', async () => {
            mockEmpireResolutionService.resolveEmpireByUserObject.mockResolvedValue(null);
            const response = await (0, supertest_1.default)(app)
                .get('/bases/A00:00:01:01/stats')
                .expect(response_formats_1.HTTP_STATUS.NOT_FOUND);
            expect(response.body).toEqual({
                success: false,
                error: response_formats_1.ERROR_MESSAGES.EMPIRE_NOT_FOUND
            });
        });
    });
    describe('GET /bases/:coord/capacities - Base Capacities (migrated from v1)', () => {
        it('should return base capacities using CapacityService (FR-16)', async () => {
            const mockCapacities = {
                construction: { value: 100, unit: 'credits/hour' },
                production: { value: 50, unit: 'units/hour' },
                research: { value: 25, unit: 'points/hour' }
            };
            // Mock CapacityService
            const mockCapacityService = {
                getBaseCapacities: jest.fn().mockResolvedValue(mockCapacities)
            };
            // Mock dynamic import { HTTP_STATUS, ERROR_MESSAGES } from '../constants/response-formats';
            jest.doMock('../../../services/bases/CapacityService', () => ({
                CapacityService: mockCapacityService
            }));
            const response = await (0, supertest_1.default)(app)
                .get('/bases/A00:00:01:01/capacities')
                .expect(response_formats_1.HTTP_STATUS.OK);
            expect(response.body).toEqual({
                success: true,
                data: mockCapacities
            });
        });
        it('should handle coordinate validation (FR-15)', async () => {
            const response = await (0, supertest_1.default)(app)
                .get('/bases//capacities')
                .expect(response_formats_1.HTTP_STATUS.BAD_REQUEST);
            expect(response.body).toEqual({
                success: false,
                error: response_formats_1.ERROR_MESSAGES.COORDINATE_PARAMETER_REQUIRED
            });
        });
    });
    describe('GET /bases/:coord/combined-stats - Combined Stats (migrated from v1)', () => {
        it('should return combined stats and capacities (FR-16)', async () => {
            const mockStats = { area: 1000, energy: response_formats_1.HTTP_STATUS.INTERNAL_SERVER_ERROR };
            const mockCapacities = { construction: 100, production: 50 };
            // Mock both services
            const mockStatsService = {
                getBaseStats: jest.fn().mockResolvedValue(mockStats)
            };
            const mockCapacityService = {
                getBaseCapacities: jest.fn().mockResolvedValue(mockCapacities)
            };
            jest.doMock('../../../services/bases/StatsService', () => ({
                StatsService: mockStatsService
            }));
            jest.doMock('../../../services/bases/CapacityService', () => ({
                CapacityService: mockCapacityService
            }));
            const response = await (0, supertest_1.default)(app)
                .get('/bases/A00:00:01:01/combined-stats')
                .expect(response_formats_1.HTTP_STATUS.OK);
            expect(response.body).toEqual({
                success: true,
                data: {
                    coord: 'A00:00:01:01',
                    stats: mockStats,
                    capacities: mockCapacities
                },
                message: 'Base stats loaded'
            });
        });
        it('should make parallel calls to both services for efficiency', async () => {
            const mockStatsService = {
                getBaseStats: jest.fn().mockResolvedValue({})
            };
            const mockCapacityService = {
                getBaseCapacities: jest.fn().mockResolvedValue({})
            };
            jest.doMock('../../../services/bases/StatsService', () => ({
                StatsService: mockStatsService
            }));
            jest.doMock('../../../services/bases/CapacityService', () => ({
                CapacityService: mockCapacityService
            }));
            await (0, supertest_1.default)(app)
                .get('/bases/A00:00:01:01/combined-stats')
                .expect(response_formats_1.HTTP_STATUS.OK);
            // Both services should be called with correct parameters
            expect(mockStatsService.getBaseStats).toHaveBeenCalledWith('empire123', 'A00:00:01:01');
            expect(mockCapacityService.getBaseCapacities).toHaveBeenCalledWith('empire123', 'A00:00:01:01');
        });
    });
    describe('Response Format Compliance (FR-12)', () => {
        it('should follow established response format for all endpoints', async () => {
            // Mock minimal data
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({ data: [], error: null })
            });
            // Test all endpoints follow the same format
            const endpoints = [
                '/bases',
                '/bases/A00:00:01:01/stats',
                '/bases/A00:00:01:01/capacities',
                '/bases/A00:00:01:01/combined-stats'
            ];
            for (const endpoint of endpoints) {
                const response = await (0, supertest_1.default)(app).get(endpoint);
                expect(response.body).toHaveProperty('success');
                expect(typeof response.body.success).toBe('boolean');
                if (response.body.success) {
                    expect(response.body).toHaveProperty('data');
                }
                else {
                    expect(response.body).toHaveProperty('error');
                }
            }
        });
    });
    describe('Authentication and Empire Resolution (FR-14)', () => {
        it('should use EmpireResolutionService consistently across all endpoints', async () => {
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({ data: [], error: null })
            });
            const endpoints = [
                '/bases',
                '/bases/A00:00:01:01/stats',
                '/bases/A00:00:01:01/capacities',
                '/bases/A00:00:01:01/combined-stats'
            ];
            for (const endpoint of endpoints) {
                jest.clearAllMocks();
                await (0, supertest_1.default)(app).get(endpoint);
                expect(mockEmpireResolutionService.resolveEmpireByUserObject)
                    .toHaveBeenCalledWith(mockUser);
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFByb2plY3RzXFxBdHRyaXRpb25cXHBhY2thZ2VzXFxzZXJ2ZXJcXHNyY1xcX190ZXN0c19fXFxiYXNlc1JvdXRlcy50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBU0EsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUMsNENBQTRDLENBQUMsQ0FBQztBQUN4RCxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsbUNBQW1DLENBQUMsQ0FBQztBQWI5QywwREFBZ0M7QUFDakMsc0RBQThCO0FBQzlCLGlFQUErQztBQUMvQyw2Q0FBa0Q7QUFDbEQsaURBQThDO0FBQzlDLG9FQUE0RTtBQUU1RSxvQkFBb0I7QUFDcEIsd0VBQStEO0FBTy9ELE1BQU0sWUFBWSxHQUFHLG1CQUF3QyxDQUFDO0FBQzlELE1BQU0sMkJBQTJCLEdBQUcsdUJBQXNFLENBQUM7QUFDM0csTUFBTSxnQkFBZ0IsR0FBRyxtQkFBd0QsQ0FBQztBQUVsRixpQkFBaUI7QUFDakIsTUFBTSxHQUFHLEdBQUcsSUFBQSxpQkFBTyxHQUFFLENBQUM7QUFDdEIsR0FBRyxDQUFDLEdBQUcsQ0FBQyxpQkFBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7QUFDeEIsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsZUFBVyxDQUFDLENBQUM7QUFFL0IsK0JBQStCO0FBQy9CLE1BQU0sUUFBUSxHQUFHO0lBQ2YsR0FBRyxFQUFFLFNBQVM7SUFDZCxFQUFFLEVBQUUsU0FBUztJQUNiLFFBQVEsRUFBRSxVQUFVO0NBQ3JCLENBQUM7QUFFRixNQUFNLFVBQVUsR0FBRztJQUNqQixFQUFFLEVBQUUsV0FBVztJQUNmLElBQUksRUFBRSxhQUFhO0lBQ25CLFdBQVcsRUFBRSxDQUFDLGNBQWMsRUFBRSxjQUFjLENBQUM7Q0FD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IjpbIkM6XFxQcm9qZWN0c1xcQXR0cml0aW9uXFxwYWNrYWdlc1xcc2VydmVyXFxzcmNcXF9fdGVzdHNfX1xcYmFzZXNSb3V0ZXMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyLvu79pbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcnRlc3QnO1xuaW1wb3J0IGV4cHJlc3MgZnJvbSAnZXhwcmVzcyc7XG5pbXBvcnQgYmFzZXNSb3V0ZXMgZnJvbSAnLi4vcm91dGVzL2dhbWUvYmFzZXMnO1xuaW1wb3J0IHsgYXV0aGVudGljYXRlIH0gZnJvbSAnLi4vbWlkZGxld2FyZS9hdXRoJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi4vY29uZmlnL3N1cGFiYXNlJztcbmltcG9ydCB7IEhUVFBfU1RBVFVTLCBFUlJPUl9NRVNTQUdFUyB9IGZyb20gJy4uL2NvbnN0YW50cy9yZXNwb25zZS1mb3JtYXRzJztcblxuLy8gTW9jayBkZXBlbmRlbmNpZXNcbmltcG9ydCB7IERCX0ZJRUxEUyB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy9kYXRhYmFzZS1maWVsZHMnO1xuamVzdC5tb2NrKCcuLi9jb25maWcvc3VwYWJhc2UnKTtcbmplc3QubW9jaygnLi4vc2VydmljZXMvZW1waXJlL0VtcGlyZVJlc29sdXRpb25TZXJ2aWNlJyk7XG5qZXN0Lm1vY2soJy4uL21pZGRsZXdhcmUvYXV0aCcpO1xuamVzdC5tb2NrKCcuLi9zZXJ2aWNlcy9iYXNlcy9TdGF0c1NlcnZpY2UnKTtcbmplc3QubW9jaygnLi4vc2VydmljZXMvYmFzZXMvQ2FwYWNpdHlTZXJ2aWNlJyk7XG5cbmNvbnN0IG1vY2tTdXBhYmFzZSA9IHN1cGFiYXNlIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBzdXBhYmFzZT47XG5jb25zdCBtb2NrRW1waXJlUmVzb2x1dGlvblNlcnZpY2UgPSBFbXBpcmVSZXNvbHV0aW9uU2VydmljZSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgRW1waXJlUmVzb2x1dGlvblNlcnZpY2U+O1xuY29uc3QgbW9ja0F1dGhlbnRpY2F0ZSA9IGF1dGhlbnRpY2F0ZSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBhdXRoZW50aWNhdGU+O1xuXG4vLyBUZXN0IGFwcCBzZXR1cFxuY29uc3QgYXBwID0gZXhwcmVzcygpO1xuYXBwLnVzZShleHByZXNzLmpzb24oKSk7XG5hcHAudXNlKCcvYmFzZXMnLCBiYXNlc1JvdXRlcyk7XG5cbi8vIE1vY2sgdXNlciBmb3IgYXV0aGVudGljYXRpb25cbmNvbnN0IG1vY2tVc2VyID0ge1xuICBfaWQ6ICd1c2VyMTIzJyxcbiAgaWQ6ICd1c2VyMTIzJyxcbiAgdXNlcm5hbWU6ICd0ZXN0dXNlcidcbn07XG5cbmNvbnN0IG1vY2tFbXBpcmUgPSB7XG4gIGlkOiAnZW1waXJlMTIzJyxcbiAgbmFtZTogJ1Rlc3QgRW1waXJlJyxcbiAgdGVycml0b3JpZXM6IFsnQTAwOjAwOjAxOjAxJywgJ0EwMDowMDowMTowMiddXG59O1xuXG5kZXNjcmliZSgnQmFzZXMgUm91dGVzIC0gVGVycml0b3J5IE1pZ3JhdGlvbiAoRlItMTYsIEZSLTE3LCBGUi0xOCknLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIE1vY2sgYXV0aGVudGljYXRpb24gbWlkZGxld2FyZVxuICAgIG1vY2tBdXRoZW50aWNhdGUubW9ja0ltcGxlbWVudGF0aW9uKChyZXE6IGFueSwgcmVzOiBhbnksIG5leHQ6IGFueSkgPT4ge1xuICAgICAgcmVxLnVzZXIgPSBtb2NrVXNlcjtcbiAgICAgIG5leHQoKTtcbiAgICB9KTtcblxuICAgIC8vIE1vY2sgZW1waXJlIHJlc29sdXRpb25cbiAgICBtb2NrRW1waXJlUmVzb2x1dGlvblNlcnZpY2UucmVzb2x2ZUVtcGlyZUJ5VXNlck9iamVjdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRW1waXJlIGFzIGFueSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHRVQgL2Jhc2VzIC0gVGVycml0b3J5IExpc3RpbmcgKG1pZ3JhdGVkIGZyb20gdjEpJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRlcnJpdG9yaWVzIGxpc3QgZnJvbSBjb2xvbmllcyB0YWJsZSAoRlItMTYpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjb2xvbmllcyBkYXRhIChwcmVmZXJyZWQgc291cmNlKVxuICAgICAgY29uc3QgbW9ja0NvbG9uaWVzID0gW1xuICAgICAgICB7IGxvY2F0aW9uX2Nvb3JkOiAnQTAwOjAwOjAxOjAxJywgbmFtZTogJ0FscGhhIEJhc2UnIH0sXG4gICAgICAgIHsgbG9jYXRpb25fY29vcmQ6ICdBMDA6MDA6MDE6MDInLCBuYW1lOiAnQmV0YSBPdXRwb3N0JyB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBtb2NrUXVlcnkgPSB7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBtb2NrQ29sb25pZXMsIGVycm9yOiBudWxsIH0pXG4gICAgICB9O1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tRdWVyeSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoYXBwKVxuICAgICAgICAuZ2V0KCcvYmFzZXMnKVxuICAgICAgICAuZXhwZWN0KEhUVFBfU1RBVFVTLk9LKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvRXF1YWwoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdGVycml0b3JpZXM6IFtcbiAgICAgICAgICAgIHsgY29vcmQ6ICdBMDA6MDA6MDE6MDEnLCBuYW1lOiAnQWxwaGEgQmFzZScgfSxcbiAgICAgICAgICAgIHsgY29vcmQ6ICdBMDA6MDA6MDE6MDInLCBuYW1lOiAnQmV0YSBPdXRwb3N0JyB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tRdWVyeS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoREJfRklFTERTLkJVSUxESU5HUy5FTVBJUkVfSUQsICdlbXBpcmUxMjMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFsbGJhY2sgdG8gZW1waXJlcy50ZXJyaXRvcmllcyB3aGVuIG5vIGNvbG9uaWVzIGV4aXN0IChGUi0xOCknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGVtcHR5IGNvbG9uaWVzLCBmYWxsYmFjayB0byBlbXBpcmUgdGVycml0b3JpZXNcbiAgICAgIGNvbnN0IG1vY2tFbXB0eUNvbG9uaWVzID0geyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfTtcbiAgICAgIGNvbnN0IG1vY2tFbXBpcmVEYXRhID0geyBkYXRhOiB7IHRlcnJpdG9yaWVzOiBbJ0EwMDowMDowMTowMScsICdBMDA6MDA6MDE6MDInXSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgY29uc3QgbW9ja0xvY2F0aW9ucyA9IHsgZGF0YTogW3sgY29vcmQ6ICdBMDA6MDA6MDE6MDEnIH0sIHsgY29vcmQ6ICdBMDA6MDA6MDE6MDInIH1dLCBlcnJvcjogbnVsbCB9O1xuXG4gICAgICBjb25zdCBtb2NrQ29sb25pZXNRdWVyeSA9IHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRW1wdHlDb2xvbmllcylcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tFbXBpcmVRdWVyeSA9IHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgICBtYXliZVNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tFbXBpcmVEYXRhKVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0xvY2F0aW9uUXVlcnkgPSB7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgIGluOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0xvY2F0aW9ucylcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDb2xvbmllc1F1ZXJ5IGFzIGFueSkgIC8vIGNvbG9uaWVzIHF1ZXJ5XG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tFbXBpcmVRdWVyeSBhcyBhbnkpICAgIC8vIGVtcGlyZXMgcXVlcnkgIFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShtb2NrTG9jYXRpb25RdWVyeSBhcyBhbnkpOyAvLyBsb2NhdGlvbnMgcXVlcnlcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGFwcClcbiAgICAgICAgLmdldCgnL2Jhc2VzJylcbiAgICAgICAgLmV4cGVjdChIVFRQX1NUQVRVUy5PSyk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5ib2R5KS50b0VxdWFsKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRlcnJpdG9yaWVzOiBbXG4gICAgICAgICAgICB7IGNvb3JkOiAnQTAwOjAwOjAxOjAxJyB9LFxuICAgICAgICAgICAgeyBjb29yZDogJ0EwMDowMDowMTowMicgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIG5vIHRlcnJpdG9yaWVzIGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0VtcHR5Q29sb25pZXMgPSB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9O1xuICAgICAgY29uc3QgbW9ja0VtcHR5RW1waXJlID0geyBkYXRhOiB7IHRlcnJpdG9yaWVzOiBbXSB9LCBlcnJvcjogbnVsbCB9O1xuXG4gICAgICBjb25zdCBtb2NrQ29sb25pZXNRdWVyeSA9IHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRW1wdHlDb2xvbmllcylcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tFbXBpcmVRdWVyeSA9IHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgICBtYXliZVNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tFbXB0eUVtcGlyZSlcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDb2xvbmllc1F1ZXJ5IGFzIGFueSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0VtcGlyZVF1ZXJ5IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChhcHApXG4gICAgICAgIC5nZXQoJy9iYXNlcycpXG4gICAgICAgIC5leHBlY3QoSFRUUF9TVEFUVVMuT0spO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2UuYm9keSkudG9FcXVhbCh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHsgdGVycml0b3JpZXM6IFtdIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDA0IHdoZW4gZW1waXJlIG5vdCBmb3VuZCAoRlItMTUpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0VtcGlyZVJlc29sdXRpb25TZXJ2aWNlLnJlc29sdmVFbXBpcmVCeVVzZXJPYmplY3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChhcHApXG4gICAgICAgIC5nZXQoJy9iYXNlcycpXG4gICAgICAgIC5leHBlY3QoSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvRXF1YWwoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IEVSUk9SX01FU1NBR0VTLkVNUElSRV9OT1RfRk9VTkRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnR0VUIC9iYXNlcy86Y29vcmQvc3RhdHMgLSBCYXNlIFN0YXRpc3RpY3MgKG1pZ3JhdGVkIGZyb20gdjEpJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGJhc2Ugc3RhdGlzdGljcyB1c2luZyBTdGF0c1NlcnZpY2UgKEZSLTE2KScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTdGF0cyA9IHtcbiAgICAgICAgYXJlYTogMTAwMCxcbiAgICAgICAgZW5lcmd5OiB7IHByb2R1Y3Rpb246IEhUVFBfU1RBVFVTLklOVEVSTkFMX1NFUlZFUl9FUlJPUiwgY29uc3VtcHRpb246IEhUVFBfU1RBVFVTLk9LIH0sXG4gICAgICAgIHBvcHVsYXRpb246IHsgY3VycmVudDogMTAwMCwgY2FwYWNpdHk6IDIwMDAgfVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBTdGF0c1NlcnZpY2VcbiAgICAgIGNvbnN0IG1vY2tTdGF0c1NlcnZpY2UgPSB7XG4gICAgICAgIGdldEJhc2VTdGF0czogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdGF0cylcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgZHluYW1pYyBpbXBvcnQgeyBIVFRQX1NUQVRVUywgRVJST1JfTUVTU0FHRVMgfSBmcm9tICcuLi9jb25zdGFudHMvcmVzcG9uc2UtZm9ybWF0cyc7XG4gICAgICBqZXN0LmRvTW9jaygnLi4vLi4vLi4vc2VydmljZXMvYmFzZXMvU3RhdHNTZXJ2aWNlJywgKCkgPT4gKHtcbiAgICAgICAgU3RhdHNTZXJ2aWNlOiBtb2NrU3RhdHNTZXJ2aWNlXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChhcHApXG4gICAgICAgIC5nZXQoJy9iYXNlcy9BMDA6MDA6MDE6MDEvc3RhdHMnKVxuICAgICAgICAuZXhwZWN0KEhUVFBfU1RBVFVTLk9LKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvRXF1YWwoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7IHN0YXRzOiBtb2NrU3RhdHMgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgd2hlbiBjb29yZGluYXRlIGlzIG1pc3NpbmcgKEZSLTE1KScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChhcHApXG4gICAgICAgIC5nZXQoJy9iYXNlcy8vc3RhdHMnKVxuICAgICAgICAuZXhwZWN0KEhUVFBfU1RBVFVTLkJBRF9SRVFVRVNUKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvRXF1YWwoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IEVSUk9SX01FU1NBR0VTLkNPT1JESU5BVEVfUEFSQU1FVEVSX1JFUVVJUkVEXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCB3aGVuIGVtcGlyZSBub3QgZm91bmQgKEZSLTE1KScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFbXBpcmVSZXNvbHV0aW9uU2VydmljZS5yZXNvbHZlRW1waXJlQnlVc2VyT2JqZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoYXBwKVxuICAgICAgICAuZ2V0KCcvYmFzZXMvQTAwOjAwOjAxOjAxL3N0YXRzJylcbiAgICAgICAgLmV4cGVjdChIVFRQX1NUQVRVUy5OT1RfRk9VTkQpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2UuYm9keSkudG9FcXVhbCh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogRVJST1JfTUVTU0FHRVMuRU1QSVJFX05PVF9GT1VORFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHRVQgL2Jhc2VzLzpjb29yZC9jYXBhY2l0aWVzIC0gQmFzZSBDYXBhY2l0aWVzIChtaWdyYXRlZCBmcm9tIHYxKScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBiYXNlIGNhcGFjaXRpZXMgdXNpbmcgQ2FwYWNpdHlTZXJ2aWNlIChGUi0xNiknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ2FwYWNpdGllcyA9IHtcbiAgICAgICAgY29uc3RydWN0aW9uOiB7IHZhbHVlOiAxMDAsIHVuaXQ6ICdjcmVkaXRzL2hvdXInIH0sXG4gICAgICAgIHByb2R1Y3Rpb246IHsgdmFsdWU6IDUwLCB1bml0OiAndW5pdHMvaG91cicgfSxcbiAgICAgICAgcmVzZWFyY2g6IHsgdmFsdWU6IDI1LCB1bml0OiAncG9pbnRzL2hvdXInIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgQ2FwYWNpdHlTZXJ2aWNlXG4gICAgICBjb25zdCBtb2NrQ2FwYWNpdHlTZXJ2aWNlID0ge1xuICAgICAgICBnZXRCYXNlQ2FwYWNpdGllczogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tDYXBhY2l0aWVzKVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBkeW5hbWljIGltcG9ydCB7IEhUVFBfU1RBVFVTLCBFUlJPUl9NRVNTQUdFUyB9IGZyb20gJy4uL2NvbnN0YW50cy9yZXNwb25zZS1mb3JtYXRzJztcbiAgICAgIGplc3QuZG9Nb2NrKCcuLi8uLi8uLi9zZXJ2aWNlcy9iYXNlcy9DYXBhY2l0eVNlcnZpY2UnLCAoKSA9PiAoe1xuICAgICAgICBDYXBhY2l0eVNlcnZpY2U6IG1vY2tDYXBhY2l0eVNlcnZpY2VcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGFwcClcbiAgICAgICAgLmdldCgnL2Jhc2VzL0EwMDowMDowMTowMS9jYXBhY2l0aWVzJylcbiAgICAgICAgLmV4cGVjdChIVFRQX1NUQVRVUy5PSyk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5ib2R5KS50b0VxdWFsKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogbW9ja0NhcGFjaXRpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29vcmRpbmF0ZSB2YWxpZGF0aW9uIChGUi0xNSknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoYXBwKVxuICAgICAgICAuZ2V0KCcvYmFzZXMvL2NhcGFjaXRpZXMnKVxuICAgICAgICAuZXhwZWN0KEhUVFBfU1RBVFVTLkJBRF9SRVFVRVNUKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvRXF1YWwoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IEVSUk9SX01FU1NBR0VTLkNPT1JESU5BVEVfUEFSQU1FVEVSX1JFUVVJUkVEXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dFVCAvYmFzZXMvOmNvb3JkL2NvbWJpbmVkLXN0YXRzIC0gQ29tYmluZWQgU3RhdHMgKG1pZ3JhdGVkIGZyb20gdjEpJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNvbWJpbmVkIHN0YXRzIGFuZCBjYXBhY2l0aWVzIChGUi0xNiknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU3RhdHMgPSB7IGFyZWE6IDEwMDAsIGVuZXJneTogSFRUUF9TVEFUVVMuSU5URVJOQUxfU0VSVkVSX0VSUk9SIH07XG4gICAgICBjb25zdCBtb2NrQ2FwYWNpdGllcyA9IHsgY29uc3RydWN0aW9uOiAxMDAsIHByb2R1Y3Rpb246IDUwIH07XG5cbiAgICAgIC8vIE1vY2sgYm90aCBzZXJ2aWNlc1xuICAgICAgY29uc3QgbW9ja1N0YXRzU2VydmljZSA9IHtcbiAgICAgICAgZ2V0QmFzZVN0YXRzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N0YXRzKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vY2tDYXBhY2l0eVNlcnZpY2UgPSB7XG4gICAgICAgIGdldEJhc2VDYXBhY2l0aWVzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NhcGFjaXRpZXMpXG4gICAgICB9O1xuXG4gICAgICBqZXN0LmRvTW9jaygnLi4vLi4vLi4vc2VydmljZXMvYmFzZXMvU3RhdHNTZXJ2aWNlJywgKCkgPT4gKHtcbiAgICAgICAgU3RhdHNTZXJ2aWNlOiBtb2NrU3RhdHNTZXJ2aWNlXG4gICAgICB9KSk7XG4gICAgICBqZXN0LmRvTW9jaygnLi4vLi4vLi4vc2VydmljZXMvYmFzZXMvQ2FwYWNpdHlTZXJ2aWNlJywgKCkgPT4gKHtcbiAgICAgICAgQ2FwYWNpdHlTZXJ2aWNlOiBtb2NrQ2FwYWNpdHlTZXJ2aWNlXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChhcHApXG4gICAgICAgIC5nZXQoJy9iYXNlcy9BMDA6MDA6MDE6MDEvY29tYmluZWQtc3RhdHMnKVxuICAgICAgICAuZXhwZWN0KEhUVFBfU1RBVFVTLk9LKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvRXF1YWwoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29vcmQ6ICdBMDA6MDA6MDE6MDEnLFxuICAgICAgICAgIHN0YXRzOiBtb2NrU3RhdHMsXG4gICAgICAgICAgY2FwYWNpdGllczogbW9ja0NhcGFjaXRpZXNcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZTogJ0Jhc2Ugc3RhdHMgbG9hZGVkJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1ha2UgcGFyYWxsZWwgY2FsbHMgdG8gYm90aCBzZXJ2aWNlcyBmb3IgZWZmaWNpZW5jeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTdGF0c1NlcnZpY2UgPSB7XG4gICAgICAgIGdldEJhc2VTdGF0czogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHt9KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vY2tDYXBhY2l0eVNlcnZpY2UgPSB7XG4gICAgICAgIGdldEJhc2VDYXBhY2l0aWVzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe30pXG4gICAgICB9O1xuXG4gICAgICBqZXN0LmRvTW9jaygnLi4vLi4vLi4vc2VydmljZXMvYmFzZXMvU3RhdHNTZXJ2aWNlJywgKCkgPT4gKHtcbiAgICAgICAgU3RhdHNTZXJ2aWNlOiBtb2NrU3RhdHNTZXJ2aWNlXG4gICAgICB9KSk7XG4gICAgICBqZXN0LmRvTW9jaygnLi4vLi4vLi4vc2VydmljZXMvYmFzZXMvQ2FwYWNpdHlTZXJ2aWNlJywgKCkgPT4gKHtcbiAgICAgICAgQ2FwYWNpdHlTZXJ2aWNlOiBtb2NrQ2FwYWNpdHlTZXJ2aWNlXG4gICAgICB9KSk7XG5cbiAgICAgIGF3YWl0IHJlcXVlc3QoYXBwKVxuICAgICAgICAuZ2V0KCcvYmFzZXMvQTAwOjAwOjAxOjAxL2NvbWJpbmVkLXN0YXRzJylcbiAgICAgICAgLmV4cGVjdChIVFRQX1NUQVRVUy5PSyk7XG5cbiAgICAgIC8vIEJvdGggc2VydmljZXMgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGNvcnJlY3QgcGFyYW1ldGVyc1xuICAgICAgZXhwZWN0KG1vY2tTdGF0c1NlcnZpY2UuZ2V0QmFzZVN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZW1waXJlMTIzJywgJ0EwMDowMDowMTowMScpO1xuICAgICAgZXhwZWN0KG1vY2tDYXBhY2l0eVNlcnZpY2UuZ2V0QmFzZUNhcGFjaXRpZXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdlbXBpcmUxMjMnLCAnQTAwOjAwOjAxOjAxJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZXNwb25zZSBGb3JtYXQgQ29tcGxpYW5jZSAoRlItMTIpJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZm9sbG93IGVzdGFibGlzaGVkIHJlc3BvbnNlIGZvcm1hdCBmb3IgYWxsIGVuZHBvaW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgbWluaW1hbCBkYXRhXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogW10sIGVycm9yOiBudWxsIH0pXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIC8vIFRlc3QgYWxsIGVuZHBvaW50cyBmb2xsb3cgdGhlIHNhbWUgZm9ybWF0XG4gICAgICBjb25zdCBlbmRwb2ludHMgPSBbXG4gICAgICAgICcvYmFzZXMnLFxuICAgICAgICAnL2Jhc2VzL0EwMDowMDowMTowMS9zdGF0cycsIFxuICAgICAgICAnL2Jhc2VzL0EwMDowMDowMTowMS9jYXBhY2l0aWVzJyxcbiAgICAgICAgJy9iYXNlcy9BMDA6MDA6MDE6MDEvY29tYmluZWQtc3RhdHMnXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIGVuZHBvaW50cykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoYXBwKS5nZXQoZW5kcG9pbnQpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvSGF2ZVByb3BlcnR5KCdzdWNjZXNzJyk7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgcmVzcG9uc2UuYm9keS5zdWNjZXNzKS50b0JlKCdib29sZWFuJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzcG9uc2UuYm9keS5zdWNjZXNzKSB7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvSGF2ZVByb3BlcnR5KCdkYXRhJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvSGF2ZVByb3BlcnR5KCdlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbiBhbmQgRW1waXJlIFJlc29sdXRpb24gKEZSLTE0KScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHVzZSBFbXBpcmVSZXNvbHV0aW9uU2VydmljZSBjb25zaXN0ZW50bHkgYWNyb3NzIGFsbCBlbmRwb2ludHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogW10sIGVycm9yOiBudWxsIH0pXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IGVuZHBvaW50cyA9IFtcbiAgICAgICAgJy9iYXNlcycsXG4gICAgICAgICcvYmFzZXMvQTAwOjAwOjAxOjAxL3N0YXRzJyxcbiAgICAgICAgJy9iYXNlcy9BMDA6MDA6MDE6MDEvY2FwYWNpdGllcycsIFxuICAgICAgICAnL2Jhc2VzL0EwMDowMDowMTowMS9jb21iaW5lZC1zdGF0cydcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgZW5kcG9pbnQgb2YgZW5kcG9pbnRzKSB7XG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgICAgICBhd2FpdCByZXF1ZXN0KGFwcCkuZ2V0KGVuZHBvaW50KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChtb2NrRW1waXJlUmVzb2x1dGlvblNlcnZpY2UucmVzb2x2ZUVtcGlyZUJ5VXNlck9iamVjdClcbiAgICAgICAgICAudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5cblxuXHJcbiJdLCJ2ZXJzaW9uIjozfQ==