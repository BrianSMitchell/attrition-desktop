26d6744fdef6709f0134dcc956ed701e
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceService = void 0;
const supabase_1 = require("../../config/supabase");
const response_formats_1 = require("../../constants/response-formats");
const database_fields_1 = require("../../constants/database-fields");
const shared_1 = require("@game/shared");
const shared_2 = require("@game/shared");
const EconomyService_1 = require("../economy/EconomyService");
class ResourceService {
    /**
     * Calculate credits per hour for an empire based on buildings
     */
    static async calculateCreditsPerHour(empireId) {
        // Use Supabase economy service to calculate from buildings
        const creditsPerHour = await EconomyService_1.EconomyService.sumCreditsPerHourForEmpire(empireId);
        // Debug logging
        if (process.env[shared_2.ENV_VARS.DEBUG_RESOURCES] === 'true') {
            const { data: empire } = await supabase_1.supabase
                .from(database_fields_1.DB_TABLES.EMPIRES)
                .select(database_fields_1.DB_FIELDS.BUILDINGS.ID)
                .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId)
                .maybeSingle();
            console.log(`ðŸ“Š Empire ${empireId} credits/hour: ${creditsPerHour}`);
        }
        return creditsPerHour;
    }
    /**
     * Update empire resources (legacy - mainly updates last update timestamp)
     */
    static async updateEmpireResources(empireId) {
        const { data: empire, error } = await supabase_1.supabase
            .from(database_fields_1.DB_TABLES.EMPIRES)
            .select('id, created_at, last_resource_update')
            .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId)
            .maybeSingle();
        if (error || !empire) {
            throw new Error(response_formats_1.ERROR_MESSAGES.EMPIRE_NOT_FOUND);
        }
        const now = new Date();
        const lastUpdate = empire.last_resource_update
            ? new Date(empire.last_resource_update)
            : new Date(empire.created_at);
        const hoursElapsed = (now.getTime() - lastUpdate.getTime()) / (shared_1.GAME_CONSTANTS.MILLISECONDS_PER_SECOND * shared_1.GAME_CONSTANTS.SECONDS_PER_MINUTE * 60);
        // Get credits per hour for diagnostics
        const creditsPerHour = await this.calculateCreditsPerHour(empireId);
        // Check if enough time has elapsed (at least 1 second)
        if (hoursElapsed < 1 / 60) {
            return { creditsPerHour, resourcesGained: {} };
        }
        // Update last resource update timestamp
        await supabase_1.supabase
            .from(database_fields_1.DB_TABLES.EMPIRES)
            .update({ last_resource_update: now.toISOString() })
            .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId);
        return { creditsPerHour, resourcesGained: {} };
    }
    /**
     * Update empire credits based on aligned time periods (top-of-period payouts)
     * Uses microcredit accumulation to prevent fractional loss
     */
    static async updateEmpireCreditsAligned(empireId) {
        const { data: empire, error } = await supabase_1.supabase
            .from(database_fields_1.DB_TABLES.EMPIRES)
            .select('id, credits, credits_remainder_milli, last_credit_payout, created_at')
            .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId)
            .maybeSingle();
        if (error || !empire) {
            throw new Error(response_formats_1.ERROR_MESSAGES.EMPIRE_NOT_FOUND);
        }
        const now = new Date();
        const periodMinutes = parseInt(process.env.CREDIT_PAYOUT_PERIOD_MINUTES || '1', 10);
        const periodMs = periodMinutes * 60 * 1000;
        // Calculate aligned boundaries
        const getBoundary = (date) => new Date(Math.floor(date.getTime() / periodMs) * periodMs);
        const currentBoundary = getBoundary(now);
        const lastPayout = empire.last_credit_payout
            ? new Date(empire.last_credit_payout)
            : new Date(empire.created_at);
        const lastBoundary = getBoundary(lastPayout);
        // Calculate how many complete periods have elapsed
        const periodsElapsed = Math.floor((currentBoundary.getTime() - lastBoundary.getTime()) / periodMs);
        if (periodsElapsed <= 0) {
            // No complete periods have elapsed
            return { creditsGained: 0 };
        }
        // Calculate production
        const creditsPerHour = await this.calculateCreditsPerHour(empireId);
        // Convert to microcredits (milli-credits) for precise calculation
        const microCreditsPerPeriod = Math.round(creditsPerHour * (periodMs / (60 * 60 * 1000)) * 1000);
        const totalMicroCredits = microCreditsPerPeriod * periodsElapsed;
        // Add to accumulated remainder
        const currentRemainder = empire.credits_remainder_milli || 0;
        const totalMicroCreditsWithRemainder = currentRemainder + totalMicroCredits;
        // Extract whole credits and new remainder
        const wholeCredits = Math.floor(totalMicroCreditsWithRemainder / 1000);
        const newRemainder = totalMicroCreditsWithRemainder % 1000;
        // Current credits
        const currentCredits = Number(empire.credits || 0);
        const newCredits = currentCredits + wholeCredits;
        // Update last payout to the most recent boundary we've paid for
        const newLastPayout = new Date(lastBoundary.getTime() + periodsElapsed * periodMs);
        // Debug logging (only in debug mode)
        if (process.env[shared_2.ENV_VARS.DEBUG_RESOURCES] === 'true') {
            console.log(`   DEBUG - Before update: credits=${currentCredits}, remainder=${currentRemainder}`);
        }
        // Update empire credits and remainder
        if (wholeCredits > 0) {
            await supabase_1.supabase
                .from(database_fields_1.DB_TABLES.EMPIRES)
                .update({
                credits: newCredits,
                credits_remainder_milli: newRemainder,
                last_credit_payout: newLastPayout.toISOString(),
            })
                .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId);
        }
        else {
            // Even if no credits awarded, update the payout timestamp and remainder
            await supabase_1.supabase
                .from(database_fields_1.DB_TABLES.EMPIRES)
                .update({
                credits_remainder_milli: newRemainder,
                last_credit_payout: newLastPayout.toISOString(),
            })
                .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId);
        }
        // Log payout transaction (non-blocking)
        if (wholeCredits > 0) {
            // Note: CreditLedgerService would need Supabase support too
            // For now, skip ledger logging in Supabase mode
            // TODO: Implement SupabaseCreditLedgerService
        }
        // Debug: Log final state (only in debug mode)
        if (process.env[shared_2.ENV_VARS.DEBUG_RESOURCES] === 'true') {
            console.log(`   DEBUG - After update: credits=${newCredits}, remainder=${newRemainder}`);
        }
        // Diagnostic logging (only in debug mode or for significant payouts)
        const shouldLogPayout = process.env[shared_2.ENV_VARS.DEBUG_RESOURCES] === 'true' || wholeCredits >= 10;
        if (shouldLogPayout) {
            console.log(`ðŸ’° Empire ${empireId}:`);
            console.log(`   Credits/Hour: ${creditsPerHour}`);
            console.log(`   Periods Elapsed: ${periodsElapsed} (${periodMinutes}min each)`);
            console.log(`   Microcredits/Period: ${microCreditsPerPeriod}`);
            console.log(`   Total Microcredits: ${totalMicroCredits}`);
            console.log(`   Previous Remainder: ${currentRemainder}`);
            console.log(`   Whole Credits Awarded: ${wholeCredits}`);
            console.log(`   New Remainder: ${newRemainder}`);
            console.log(`   Final Credits: ${newCredits}`);
        }
        return { creditsGained: wholeCredits };
    }
    /**
     * Check if empire has enough credits
     */
    static async canAfford(empireId, creditsNeeded) {
        const { data: empire, error } = await supabase_1.supabase
            .from(database_fields_1.DB_TABLES.EMPIRES)
            .select(database_fields_1.DB_FIELDS.EMPIRES.CREDITS)
            .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId)
            .maybeSingle();
        if (error || !empire) {
            return false;
        }
        const currentCredits = Number(empire.credits || 0);
        return currentCredits >= creditsNeeded;
    }
    /**
     * Deduct credits from empire
     */
    static async deductCredits(empireId, amount) {
        // Check if can afford
        const canAfford = await this.canAfford(empireId, amount);
        if (!canAfford) {
            return false;
        }
        // Get current credits
        const { data: empire, error } = await supabase_1.supabase
            .from(database_fields_1.DB_TABLES.EMPIRES)
            .select(database_fields_1.DB_FIELDS.EMPIRES.CREDITS)
            .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId)
            .maybeSingle();
        if (error || !empire) {
            return false;
        }
        const currentCredits = Number(empire.credits || 0);
        const newCredits = currentCredits - amount;
        // Update credits
        await supabase_1.supabase
            .from(database_fields_1.DB_TABLES.EMPIRES)
            .update({ credits: newCredits })
            .eq(database_fields_1.DB_FIELDS.BUILDINGS.ID, empireId);
        return true;
    }
}
exports.ResourceService = ResourceService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFByb2plY3RzXFxBdHRyaXRpb25cXHBhY2thZ2VzXFxzZXJ2ZXJcXHNyY1xcc2VydmljZXNcXHJlc291cmNlc1xcUmVzb3VyY2VTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLG9EQUFpRDtBQUNqRCx1RUFBa0U7QUFDbEUscUVBQXVFO0FBQ3ZFLHlDQUE4QztBQUM5Qyx5Q0FBd0M7QUFDeEMsOERBQTJEO0FBRTNELE1BQWEsZUFBZTtJQUMxQjs7T0FFRztJQUNLLE1BQU0sQ0FBQyxLQUFLLENBQUMsdUJBQXVCLENBQUMsUUFBZ0I7UUFDM0QsMkRBQTJEO1FBQy9ELE1BQU0sY0FBYyxHQUFHLE1BQU0sK0JBQWMsQ0FBQywwQkFBMEIsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU3RSxnQkFBZ0I7UUFDaEIsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFRLENBQUMsZUFBZSxDQUFDLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDckQsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLG1CQUFRO2lCQUNwQyxJQUFJLENBQUMsMkJBQVMsQ0FBQyxPQUFPLENBQUM7aUJBQ3ZCLE1BQU0sQ0FBQywyQkFBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7aUJBQzlCLEVBQUUsQ0FBQywyQkFBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDO2lCQUNwQyxXQUFXLEVBQUUsQ0FBQztZQUNqQixPQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsUUFBUSxrQkFBa0IsY0FBYyxFQUFFLENBQUMsQ0FBQztRQUN2RSxDQUFDO1FBRUQsT0FBTyxjQUFjLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxRQUFnQjtRQUlqRCxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLG1CQUFRO2FBQzNDLElBQUksQ0FBQywyQkFBUyxDQUFDLE9BQU8sQ0FBQzth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LFdBQVcsRUFBRSxDQUFDO1FBRWpCLElBQUksS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDckIsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDbkQsTUFBTSxVQUFVLEdBQUcsY0FBYyxHQUFHLE1BQU0sQ0FBQztRQUUzQyxpQkFBaUI7UUFDakIsTUFBTSxtQkFBUTthQUNYLElBQUksQ0FBQywyQkFBUyxDQUFDLE9BQU8sQ0FBQzthQUN2QixNQUFNLENBQUMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUM7YUFDL0IsRUFBRSxDQUFDLDJCQUFTLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV4QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7Q0FDRjtBQWxPRCwwQ0FrT0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFxBdHRyaXRpb25cXHBhY2thZ2VzXFxzZXJ2ZXJcXHNyY1xcc2VydmljZXNcXHJlc291cmNlc1xcUmVzb3VyY2VTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi4vLi4vY29uZmlnL3N1cGFiYXNlJztcbmltcG9ydCB7IEVSUk9SX01FU1NBR0VTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3Jlc3BvbnNlLWZvcm1hdHMnO1xuaW1wb3J0IHsgREJfVEFCTEVTLCBEQl9GSUVMRFMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvZGF0YWJhc2UtZmllbGRzJztcbmltcG9ydCB7IEdBTUVfQ09OU1RBTlRTIH0gZnJvbSAnQGdhbWUvc2hhcmVkJztcbmltcG9ydCB7IEVOVl9WQVJTIH0gZnJvbSAnQGdhbWUvc2hhcmVkJztcbmltcG9ydCB7IEVjb25vbXlTZXJ2aWNlIH0gZnJvbSAnLi4vZWNvbm9teS9FY29ub215U2VydmljZSc7XG5cbmV4cG9ydCBjbGFzcyBSZXNvdXJjZVNlcnZpY2Uge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIGNyZWRpdHMgcGVyIGhvdXIgZm9yIGFuIGVtcGlyZSBiYXNlZCBvbiBidWlsZGluZ3NcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGNhbGN1bGF0ZUNyZWRpdHNQZXJIb3VyKGVtcGlyZUlkOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIC8vIFVzZSBTdXBhYmFzZSBlY29ub215IHNlcnZpY2UgdG8gY2FsY3VsYXRlIGZyb20gYnVpbGRpbmdzXG5jb25zdCBjcmVkaXRzUGVySG91ciA9IGF3YWl0IEVjb25vbXlTZXJ2aWNlLnN1bUNyZWRpdHNQZXJIb3VyRm9yRW1waXJlKGVtcGlyZUlkKTtcblxuICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICBpZiAocHJvY2Vzcy5lbnZbRU5WX1ZBUlMuREVCVUdfUkVTT1VSQ0VTXSA9PT0gJ3RydWUnKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IGVtcGlyZSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oREJfVEFCTEVTLkVNUElSRVMpXG4gICAgICAgIC5zZWxlY3QoREJfRklFTERTLkJVSUxESU5HUy5JRClcbiAgICAgICAgLmVxKERCX0ZJRUxEUy5CVUlMRElOR1MuSUQsIGVtcGlyZUlkKVxuICAgICAgICAubWF5YmVTaW5nbGUoKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEVtcGlyZSAke2VtcGlyZUlkfSBjcmVkaXRzL2hvdXI6ICR7Y3JlZGl0c1BlckhvdXJ9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWRpdHNQZXJIb3VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlbXBpcmUgcmVzb3VyY2VzIChsZWdhY3kgLSBtYWlubHkgdXBkYXRlcyBsYXN0IHVwZGF0ZSB0aW1lc3RhbXApXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdXBkYXRlRW1waXJlUmVzb3VyY2VzKGVtcGlyZUlkOiBzdHJpbmcpOiBQcm9taXNlPHtcbiAgICBjcmVkaXRzUGVySG91cjogbnVtYmVyO1xuICAgIHJlc291cmNlc0dhaW5lZDogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgfT4ge1xuICAgIGNvbnN0IHsgZGF0YTogZW1waXJlLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKERCX1RBQkxFUy5FTVBJUkVTKVxuICAgICAgLnNlbGVjdCgnaWQsIGNyZWF0ZWRfYXQsIGxhc3RfcmVzb3VyY2VfdXBkYXRlJylcbiAgICAgIC5lcShEQl9GSUVMRFMuQlVJTERJTkdTLklELCBlbXBpcmVJZClcbiAgICAgIC5tYXliZVNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yIHx8ICFlbXBpcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NRVNTQUdFUy5FTVBJUkVfTk9UX0ZPVU5EKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGxhc3RVcGRhdGUgPSBlbXBpcmUubGFzdF9yZXNvdXJjZV91cGRhdGUgXG4gICAgICA/IG5ldyBEYXRlKGVtcGlyZS5sYXN0X3Jlc291cmNlX3VwZGF0ZSlcbiAgICAgIDogbmV3IERhdGUoZW1waXJlLmNyZWF0ZWRfYXQpO1xuICAgIGNvbnN0IGhvdXJzRWxhcHNlZCA9IChub3cuZ2V0VGltZSgpIC0gbGFzdFVwZGF0ZS5nZXRUaW1lKCkpIC8gKEdBTUVfQ09OU1RBTlRTLk1JTExJU0VDT05EU19QRVJfU0VDT05EICogR0FNRV9DT05TVEFOVFMuU0VDT05EU19QRVJfTUlOVVRFICogNjApO1xuXG4gICAgLy8gR2V0IGNyZWRpdHMgcGVyIGhvdXIgZm9yIGRpYWdub3N0aWNzXG4gICAgY29uc3QgY3JlZGl0c1BlckhvdXIgPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUNyZWRpdHNQZXJIb3VyKGVtcGlyZUlkKTtcblxuICAgIC8vIENoZWNrIGlmIGVub3VnaCB0aW1lIGhhcyBlbGFwc2VkIChhdCBsZWFzdCAxIHNlY29uZClcbiAgICBpZiAoaG91cnNFbGFwc2VkIDwgMSAvIDYwKSB7XG4gICAgICByZXR1cm4geyBjcmVkaXRzUGVySG91ciwgcmVzb3VyY2VzR2FpbmVkOiB7fSB9O1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBsYXN0IHJlc291cmNlIHVwZGF0ZSB0aW1lc3RhbXBcbiAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oREJfVEFCTEVTLkVNUElSRVMpXG4gICAgICAudXBkYXRlKHsgbGFzdF9yZXNvdXJjZV91cGRhdGU6IG5vdy50b0lTT1N0cmluZygpIH0pXG4gICAgICAuZXEoREJfRklFTERTLkJVSUxESU5HUy5JRCwgZW1waXJlSWQpO1xuXG4gICAgcmV0dXJuIHsgY3JlZGl0c1BlckhvdXIsIHJlc291cmNlc0dhaW5lZDoge30gfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZW1waXJlIGNyZWRpdHMgYmFzZWQgb24gYWxpZ25lZCB0aW1lIHBlcmlvZHMgKHRvcC1vZi1wZXJpb2QgcGF5b3V0cylcbiAgICogVXNlcyBtaWNyb2NyZWRpdCBhY2N1bXVsYXRpb24gdG8gcHJldmVudCBmcmFjdGlvbmFsIGxvc3NcbiAgICovXG4gIHN0YXRpYyBhc3luYyB1cGRhdGVFbXBpcmVDcmVkaXRzQWxpZ25lZChlbXBpcmVJZDogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgY3JlZGl0c0dhaW5lZDogbnVtYmVyO1xuICB9PiB7XG4gICAgY29uc3QgeyBkYXRhOiBlbXBpcmUsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oREJfVEFCTEVTLkVNUElSRVMpXG4gICAgICAuc2VsZWN0KCdpZCwgY3JlZGl0cywgY3JlZGl0c19yZW1haW5kZXJfbWlsbGksIGxhc3RfY3JlZGl0X3BheW91dCwgY3JlYXRlZF9hdCcpXG4gICAgICAuZXEoREJfRklFTERTLkJVSUxESU5HUy5JRCwgZW1waXJlSWQpXG4gICAgICAubWF5YmVTaW5nbGUoKTtcblxuICAgIGlmIChlcnJvciB8fCAhZW1waXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTUVTU0FHRVMuRU1QSVJFX05PVF9GT1VORCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBwZXJpb2RNaW51dGVzID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuQ1JFRElUX1BBWU9VVF9QRVJJT0RfTUlOVVRFUyB8fCAnMScsIDEwKTtcbiAgICBjb25zdCBwZXJpb2RNcyA9IHBlcmlvZE1pbnV0ZXMgKiA2MCAqIDEwMDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWxpZ25lZCBib3VuZGFyaWVzXG4gICAgY29uc3QgZ2V0Qm91bmRhcnkgPSAoZGF0ZTogRGF0ZSkgPT4gbmV3IERhdGUoTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIHBlcmlvZE1zKSAqIHBlcmlvZE1zKTtcblxuICAgIGNvbnN0IGN1cnJlbnRCb3VuZGFyeSA9IGdldEJvdW5kYXJ5KG5vdyk7XG4gICAgY29uc3QgbGFzdFBheW91dCA9IGVtcGlyZS5sYXN0X2NyZWRpdF9wYXlvdXRcbiAgICAgID8gbmV3IERhdGUoZW1waXJlLmxhc3RfY3JlZGl0X3BheW91dClcbiAgICAgIDogbmV3IERhdGUoZW1waXJlLmNyZWF0ZWRfYXQpO1xuICAgIGNvbnN0IGxhc3RCb3VuZGFyeSA9IGdldEJvdW5kYXJ5KGxhc3RQYXlvdXQpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGhvdyBtYW55IGNvbXBsZXRlIHBlcmlvZHMgaGF2ZSBlbGFwc2VkXG4gICAgY29uc3QgcGVyaW9kc0VsYXBzZWQgPSBNYXRoLmZsb29yKChjdXJyZW50Qm91bmRhcnkuZ2V0VGltZSgpIC0gbGFzdEJvdW5kYXJ5LmdldFRpbWUoKSkgLyBwZXJpb2RNcyk7XG5cbiAgICBpZiAocGVyaW9kc0VsYXBzZWQgPD0gMCkge1xuICAgICAgLy8gTm8gY29tcGxldGUgcGVyaW9kcyBoYXZlIGVsYXBzZWRcbiAgICAgIHJldHVybiB7IGNyZWRpdHNHYWluZWQ6IDAgfTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgcHJvZHVjdGlvblxuICAgIGNvbnN0IGNyZWRpdHNQZXJIb3VyID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVDcmVkaXRzUGVySG91cihlbXBpcmVJZCk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIG1pY3JvY3JlZGl0cyAobWlsbGktY3JlZGl0cykgZm9yIHByZWNpc2UgY2FsY3VsYXRpb25cbiAgICBjb25zdCBtaWNyb0NyZWRpdHNQZXJQZXJpb2QgPSBNYXRoLnJvdW5kKGNyZWRpdHNQZXJIb3VyICogKHBlcmlvZE1zIC8gKDYwICogNjAgKiAxMDAwKSkgKiAxMDAwKTtcbiAgICBjb25zdCB0b3RhbE1pY3JvQ3JlZGl0cyA9IG1pY3JvQ3JlZGl0c1BlclBlcmlvZCAqIHBlcmlvZHNFbGFwc2VkO1xuXG4gICAgLy8gQWRkIHRvIGFjY3VtdWxhdGVkIHJlbWFpbmRlclxuICAgIGNvbnN0IGN1cnJlbnRSZW1haW5kZXIgPSBlbXBpcmUuY3JlZGl0c19yZW1haW5kZXJfbWlsbGkgfHwgMDtcbiAgICBjb25zdCB0b3RhbE1pY3JvQ3JlZGl0c1dpdGhSZW1haW5kZXIgPSBjdXJyZW50UmVtYWluZGVyICsgdG90YWxNaWNyb0NyZWRpdHM7XG5cbiAgICAvLyBFeHRyYWN0IHdob2xlIGNyZWRpdHMgYW5kIG5ldyByZW1haW5kZXJcbiAgICBjb25zdCB3aG9sZUNyZWRpdHMgPSBNYXRoLmZsb29yKHRvdGFsTWljcm9DcmVkaXRzV2l0aFJlbWFpbmRlciAvIDEwMDApO1xuICAgIGNvbnN0IG5ld1JlbWFpbmRlciA9IHRvdGFsTWljcm9DcmVkaXRzV2l0aFJlbWFpbmRlciAlIDEwMDA7XG5cbiAgICAvLyBDdXJyZW50IGNyZWRpdHNcbiAgICBjb25zdCBjdXJyZW50Q3JlZGl0cyA9IE51bWJlcihlbXBpcmUuY3JlZGl0cyB8fCAwKTtcbiAgICBjb25zdCBuZXdDcmVkaXRzID0gY3VycmVudENyZWRpdHMgKyB3aG9sZUNyZWRpdHM7XG5cbiAgICAvLyBVcGRhdGUgbGFzdCBwYXlvdXQgdG8gdGhlIG1vc3QgcmVjZW50IGJvdW5kYXJ5IHdlJ3ZlIHBhaWQgZm9yXG4gICAgY29uc3QgbmV3TGFzdFBheW91dCA9IG5ldyBEYXRlKGxhc3RCb3VuZGFyeS5nZXRUaW1lKCkgKyBwZXJpb2RzRWxhcHNlZCAqIHBlcmlvZE1zKTtcblxuICAgIC8vIERlYnVnIGxvZ2dpbmcgKG9ubHkgaW4gZGVidWcgbW9kZSlcbiAgICBpZiAocHJvY2Vzcy5lbnZbRU5WX1ZBUlMuREVCVUdfUkVTT1VSQ0VTXSA9PT0gJ3RydWUnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgICAgREVCVUcgLSBCZWZvcmUgdXBkYXRlOiBjcmVkaXRzPSR7Y3VycmVudENyZWRpdHN9LCByZW1haW5kZXI9JHtjdXJyZW50UmVtYWluZGVyfWApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBlbXBpcmUgY3JlZGl0cyBhbmQgcmVtYWluZGVyXG4gICAgaWYgKHdob2xlQ3JlZGl0cyA+IDApIHtcbiAgICAgIGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKERCX1RBQkxFUy5FTVBJUkVTKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBjcmVkaXRzOiBuZXdDcmVkaXRzLFxuICAgICAgICAgIGNyZWRpdHNfcmVtYWluZGVyX21pbGxpOiBuZXdSZW1haW5kZXIsXG4gICAgICAgICAgbGFzdF9jcmVkaXRfcGF5b3V0OiBuZXdMYXN0UGF5b3V0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pXG4gICAgICAgIC5lcShEQl9GSUVMRFMuQlVJTERJTkdTLklELCBlbXBpcmVJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gaWYgbm8gY3JlZGl0cyBhd2FyZGVkLCB1cGRhdGUgdGhlIHBheW91dCB0aW1lc3RhbXAgYW5kIHJlbWFpbmRlclxuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oREJfVEFCTEVTLkVNUElSRVMpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIGNyZWRpdHNfcmVtYWluZGVyX21pbGxpOiBuZXdSZW1haW5kZXIsXG4gICAgICAgICAgbGFzdF9jcmVkaXRfcGF5b3V0OiBuZXdMYXN0UGF5b3V0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pXG4gICAgICAgIC5lcShEQl9GSUVMRFMuQlVJTERJTkdTLklELCBlbXBpcmVJZCk7XG4gICAgfVxuXG4gICAgLy8gTG9nIHBheW91dCB0cmFuc2FjdGlvbiAobm9uLWJsb2NraW5nKVxuICAgIGlmICh3aG9sZUNyZWRpdHMgPiAwKSB7XG4gICAgICAvLyBOb3RlOiBDcmVkaXRMZWRnZXJTZXJ2aWNlIHdvdWxkIG5lZWQgU3VwYWJhc2Ugc3VwcG9ydCB0b29cbiAgICAgIC8vIEZvciBub3csIHNraXAgbGVkZ2VyIGxvZ2dpbmcgaW4gU3VwYWJhc2UgbW9kZVxuICAgICAgLy8gVE9ETzogSW1wbGVtZW50IFN1cGFiYXNlQ3JlZGl0TGVkZ2VyU2VydmljZVxuICAgIH1cblxuICAgIC8vIERlYnVnOiBMb2cgZmluYWwgc3RhdGUgKG9ubHkgaW4gZGVidWcgbW9kZSlcbiAgICBpZiAocHJvY2Vzcy5lbnZbRU5WX1ZBUlMuREVCVUdfUkVTT1VSQ0VTXSA9PT0gJ3RydWUnKSB7XG4gICAgICBjb25zb2xlLmxvZyhgICAgREVCVUcgLSBBZnRlciB1cGRhdGU6IGNyZWRpdHM9JHtuZXdDcmVkaXRzfSwgcmVtYWluZGVyPSR7bmV3UmVtYWluZGVyfWApO1xuICAgIH1cblxuICAgIC8vIERpYWdub3N0aWMgbG9nZ2luZyAob25seSBpbiBkZWJ1ZyBtb2RlIG9yIGZvciBzaWduaWZpY2FudCBwYXlvdXRzKVxuICAgIGNvbnN0IHNob3VsZExvZ1BheW91dCA9IHByb2Nlc3MuZW52W0VOVl9WQVJTLkRFQlVHX1JFU09VUkNFU10gPT09ICd0cnVlJyB8fCB3aG9sZUNyZWRpdHMgPj0gMTA7XG4gICAgaWYgKHNob3VsZExvZ1BheW91dCkge1xuICAgICAgY29uc29sZS5sb2coYPCfkrAgRW1waXJlICR7ZW1waXJlSWR9OmApO1xuICAgICAgY29uc29sZS5sb2coYCAgIENyZWRpdHMvSG91cjogJHtjcmVkaXRzUGVySG91cn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgICBQZXJpb2RzIEVsYXBzZWQ6ICR7cGVyaW9kc0VsYXBzZWR9ICgke3BlcmlvZE1pbnV0ZXN9bWluIGVhY2gpYCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgTWljcm9jcmVkaXRzL1BlcmlvZDogJHttaWNyb0NyZWRpdHNQZXJQZXJpb2R9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgVG90YWwgTWljcm9jcmVkaXRzOiAke3RvdGFsTWljcm9DcmVkaXRzfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIFByZXZpb3VzIFJlbWFpbmRlcjogJHtjdXJyZW50UmVtYWluZGVyfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIFdob2xlIENyZWRpdHMgQXdhcmRlZDogJHt3aG9sZUNyZWRpdHN9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgTmV3IFJlbWFpbmRlcjogJHtuZXdSZW1haW5kZXJ9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgRmluYWwgQ3JlZGl0czogJHtuZXdDcmVkaXRzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNyZWRpdHNHYWluZWQ6IHdob2xlQ3JlZGl0cyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGVtcGlyZSBoYXMgZW5vdWdoIGNyZWRpdHNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjYW5BZmZvcmQoZW1waXJlSWQ6IHN0cmluZywgY3JlZGl0c05lZWRlZDogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgeyBkYXRhOiBlbXBpcmUsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oREJfVEFCTEVTLkVNUElSRVMpXG4gICAgICAuc2VsZWN0KERCX0ZJRUxEUy5FTVBJUkVTLkNSRURJVFMpXG4gICAgICAuZXEoREJfRklFTERTLkJVSUxESU5HUy5JRCwgZW1waXJlSWQpXG4gICAgICAubWF5YmVTaW5nbGUoKTtcblxuICAgIGlmIChlcnJvciB8fCAhZW1waXJlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudENyZWRpdHMgPSBOdW1iZXIoZW1waXJlLmNyZWRpdHMgfHwgMCk7XG4gICAgcmV0dXJuIGN1cnJlbnRDcmVkaXRzID49IGNyZWRpdHNOZWVkZWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVkdWN0IGNyZWRpdHMgZnJvbSBlbXBpcmVcbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWR1Y3RDcmVkaXRzKGVtcGlyZUlkOiBzdHJpbmcsIGFtb3VudDogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gQ2hlY2sgaWYgY2FuIGFmZm9yZFxuICAgIGNvbnN0IGNhbkFmZm9yZCA9IGF3YWl0IHRoaXMuY2FuQWZmb3JkKGVtcGlyZUlkLCBhbW91bnQpO1xuICAgIGlmICghY2FuQWZmb3JkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgY3JlZGl0c1xuICAgIGNvbnN0IHsgZGF0YTogZW1waXJlLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKERCX1RBQkxFUy5FTVBJUkVTKVxuICAgICAgLnNlbGVjdChEQl9GSUVMRFMuRU1QSVJFUy5DUkVESVRTKVxuICAgICAgLmVxKERCX0ZJRUxEUy5CVUlMRElOR1MuSUQsIGVtcGlyZUlkKVxuICAgICAgLm1heWJlU2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IgfHwgIWVtcGlyZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRDcmVkaXRzID0gTnVtYmVyKGVtcGlyZS5jcmVkaXRzIHx8IDApO1xuICAgIGNvbnN0IG5ld0NyZWRpdHMgPSBjdXJyZW50Q3JlZGl0cyAtIGFtb3VudDtcblxuICAgIC8vIFVwZGF0ZSBjcmVkaXRzXG4gICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKERCX1RBQkxFUy5FTVBJUkVTKVxuICAgICAgLnVwZGF0ZSh7IGNyZWRpdHM6IG5ld0NyZWRpdHMgfSlcbiAgICAgIC5lcShEQl9GSUVMRFMuQlVJTERJTkdTLklELCBlbXBpcmVJZCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5cbiJdLCJ2ZXJzaW9uIjozfQ==